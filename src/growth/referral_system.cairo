//! Referral System - Drive adoption through affiliate rewards
//!
//! Features:
//! - Unique referral codes for each user
//! - Tiered rewards based on referral volume
//! - Fee sharing from referred trades
//! - Multi-level referrals (optional)
//! - Anti-gaming protections
//!
//! Reward Structure:
//! - Bronze: 10% of fees from referrals
//! - Silver (10+ referrals): 15% of fees
//! - Gold (50+ referrals): 20% of fees
//! - Platinum (200+ referrals): 25% of fees

use starknet::ContractAddress;

/// Referrer tier based on performance
#[derive(Copy, Drop, Serde, starknet::Store, PartialEq, Default)]
pub enum ReferrerTier {
    #[default]
    Bronze,    // 0-9 active referrals, 10% fee share
    Silver,    // 10-49 active referrals, 15% fee share
    Gold,      // 50-199 active referrals, 20% fee share
    Platinum,  // 200+ active referrals, 25% fee share
}

/// Referrer profile
#[derive(Copy, Drop, Serde, starknet::Store)]
pub struct ReferrerProfile {
    /// Unique referral code (felt252 for gas efficiency)
    pub referral_code: felt252,
    /// Current tier
    pub tier: ReferrerTier,
    /// Total referrals count
    pub total_referrals: u32,
    /// Active referrals (traded in last 30 days)
    pub active_referrals: u32,
    /// Total volume generated by referrals (in USD, 18 decimals)
    pub total_volume_usd: u256,
    /// Total rewards earned (in SAGE, 18 decimals)
    pub total_rewards_earned: u256,
    /// Pending rewards to claim
    pub pending_rewards: u256,
    /// Registration timestamp
    pub registered_at: u64,
    /// Whether referrer is active
    pub is_active: bool,
}

/// Referred user info
#[derive(Copy, Drop, Serde, starknet::Store)]
pub struct ReferredUser {
    /// Who referred this user
    pub referrer: ContractAddress,
    /// When they were referred
    pub referred_at: u64,
    /// Total volume traded
    pub total_volume_usd: u256,
    /// Total fees generated
    pub total_fees_generated: u256,
    /// Last trade timestamp
    pub last_trade_at: u64,
    /// Whether considered active (traded in last 30 days)
    pub is_active: bool,
}

/// Referral system configuration
#[derive(Copy, Drop, Serde, starknet::Store)]
pub struct ReferralConfig {
    /// Bronze tier fee share (basis points, 1000 = 10%)
    pub bronze_fee_share_bps: u32,
    /// Silver tier fee share
    pub silver_fee_share_bps: u32,
    /// Gold tier fee share
    pub gold_fee_share_bps: u32,
    /// Platinum tier fee share
    pub platinum_fee_share_bps: u32,
    /// Referrals needed for Silver tier
    pub silver_threshold: u32,
    /// Referrals needed for Gold tier
    pub gold_threshold: u32,
    /// Referrals needed for Platinum tier
    pub platinum_threshold: u32,
    /// Minimum trade volume to count as "active" (in USD)
    pub min_active_volume_usd: u256,
    /// Days of inactivity before referral is considered inactive
    pub inactivity_days: u64,
    /// Whether self-referral is blocked
    pub block_self_referral: bool,
    /// Whether system is paused
    pub paused: bool,
}

#[starknet::interface]
pub trait IReferralSystem<TContractState> {
    // =========================================================================
    // Referrer Functions
    // =========================================================================

    /// Register as a referrer and get a unique code
    fn register_referrer(ref self: TContractState) -> felt252;

    /// Register with a custom referral code (if available)
    fn register_referrer_with_code(ref self: TContractState, code: felt252) -> bool;

    /// Claim pending referral rewards
    fn claim_rewards(ref self: TContractState) -> u256;

    /// Get referrer profile
    fn get_referrer_profile(self: @TContractState, referrer: ContractAddress) -> ReferrerProfile;

    /// Get referrer by code
    fn get_referrer_by_code(self: @TContractState, code: felt252) -> ContractAddress;

    // =========================================================================
    // Referred User Functions
    // =========================================================================

    /// Register as referred by a code
    fn register_with_referral(ref self: TContractState, referral_code: felt252);

    /// Get referral info for a user
    fn get_referral_info(self: @TContractState, user: ContractAddress) -> ReferredUser;

    /// Check if user has a referrer
    fn has_referrer(self: @TContractState, user: ContractAddress) -> bool;

    // =========================================================================
    // Integration Functions (called by orderbook/payment contracts)
    // =========================================================================

    /// Record a trade and distribute referral rewards
    /// Called by authorized contracts (orderbook, payment router)
    fn record_trade(
        ref self: TContractState,
        trader: ContractAddress,
        volume_usd: u256,
        fee_amount: u256,
        fee_token: ContractAddress
    );

    // =========================================================================
    // View Functions
    // =========================================================================

    /// Get system configuration
    fn get_config(self: @TContractState) -> ReferralConfig;

    /// Get total stats
    fn get_stats(self: @TContractState) -> (u256, u256, u32, u32);  // total_volume, total_rewards, total_referrers, total_referred

    /// Get fee share for a tier
    fn get_fee_share(self: @TContractState, tier: ReferrerTier) -> u32;

    /// Calculate tier from referral count
    fn calculate_tier(self: @TContractState, active_referrals: u32) -> ReferrerTier;

    // =========================================================================
    // Admin Functions
    // =========================================================================

    /// Update configuration
    fn set_config(ref self: TContractState, config: ReferralConfig);

    /// Add authorized caller (orderbook, payment router, etc.)
    fn add_authorized_caller(ref self: TContractState, caller: ContractAddress);

    /// Remove authorized caller
    fn remove_authorized_caller(ref self: TContractState, caller: ContractAddress);

    /// Pause/unpause
    fn pause(ref self: TContractState);
    fn unpause(ref self: TContractState);

    /// Emergency withdraw
    fn emergency_withdraw(ref self: TContractState, token: ContractAddress, amount: u256);
}

#[starknet::contract]
mod ReferralSystem {
    use super::{
        IReferralSystem, ReferrerTier, ReferrerProfile, ReferredUser, ReferralConfig
    };
    use starknet::{ContractAddress, get_caller_address, get_block_timestamp, get_contract_address};
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess,
        StorageMapReadAccess, StorageMapWriteAccess, Map
    };
    use core::num::traits::Zero;
    use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};

    const BPS_DENOMINATOR: u256 = 10000;
    const SECONDS_PER_DAY: u64 = 86400;

    #[storage]
    struct Storage {
        owner: ContractAddress,
        reward_token: ContractAddress,  // SAGE token for rewards
        config: ReferralConfig,

        // Referrer data
        referrer_profiles: Map<ContractAddress, ReferrerProfile>,
        referral_codes: Map<felt252, ContractAddress>,  // code -> referrer
        referrer_count: u32,

        // Referred user data
        referred_users: Map<ContractAddress, ReferredUser>,
        referred_count: u32,

        // Referrer's referrals list (referrer, index) -> referred_user
        referrer_referrals_count: Map<ContractAddress, u32>,
        referrer_referrals: Map<(ContractAddress, u32), ContractAddress>,

        // Authorized callers (orderbook, payment router)
        authorized_callers: Map<ContractAddress, bool>,

        // Stats
        total_volume_usd: u256,
        total_rewards_distributed: u256,

        // Nonce for generating codes
        code_nonce: u256,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        ReferrerRegistered: ReferrerRegistered,
        UserReferred: UserReferred,
        TradeRecorded: TradeRecorded,
        RewardsClaimed: RewardsClaimed,
        TierUpgrade: TierUpgrade,
        ConfigUpdated: ConfigUpdated,
    }

    #[derive(Drop, starknet::Event)]
    struct ReferrerRegistered {
        #[key]
        referrer: ContractAddress,
        referral_code: felt252,
        timestamp: u64,
    }

    #[derive(Drop, starknet::Event)]
    struct UserReferred {
        #[key]
        user: ContractAddress,
        #[key]
        referrer: ContractAddress,
        referral_code: felt252,
        timestamp: u64,
    }

    #[derive(Drop, starknet::Event)]
    struct TradeRecorded {
        #[key]
        trader: ContractAddress,
        #[key]
        referrer: ContractAddress,
        volume_usd: u256,
        fee_amount: u256,
        referrer_reward: u256,
    }

    #[derive(Drop, starknet::Event)]
    struct RewardsClaimed {
        #[key]
        referrer: ContractAddress,
        amount: u256,
        timestamp: u64,
    }

    #[derive(Drop, starknet::Event)]
    struct TierUpgrade {
        #[key]
        referrer: ContractAddress,
        old_tier: ReferrerTier,
        new_tier: ReferrerTier,
        active_referrals: u32,
    }

    #[derive(Drop, starknet::Event)]
    struct ConfigUpdated {
        updated_by: ContractAddress,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        owner: ContractAddress,
        reward_token: ContractAddress,
    ) {
        self.owner.write(owner);
        self.reward_token.write(reward_token);

        // Default configuration
        self.config.write(ReferralConfig {
            bronze_fee_share_bps: 1000,    // 10%
            silver_fee_share_bps: 1500,    // 15%
            gold_fee_share_bps: 2000,      // 20%
            platinum_fee_share_bps: 2500,  // 25%
            silver_threshold: 10,
            gold_threshold: 50,
            platinum_threshold: 200,
            min_active_volume_usd: 100_000000000000000000,  // $100 minimum
            inactivity_days: 30,
            block_self_referral: true,
            paused: false,
        });

        self.code_nonce.write(1);
    }

    #[abi(embed_v0)]
    impl ReferralSystemImpl of IReferralSystem<ContractState> {
        fn register_referrer(ref self: ContractState) -> felt252 {
            self._require_not_paused();

            let caller = get_caller_address();

            // Check not already registered
            let existing = self.referrer_profiles.read(caller);
            assert!(existing.referral_code == 0, "Already registered as referrer");

            // Generate unique code
            let code = self._generate_code(caller);

            // Create profile
            let profile = ReferrerProfile {
                referral_code: code,
                tier: ReferrerTier::Bronze,
                total_referrals: 0,
                active_referrals: 0,
                total_volume_usd: 0,
                total_rewards_earned: 0,
                pending_rewards: 0,
                registered_at: get_block_timestamp(),
                is_active: true,
            };

            self.referrer_profiles.write(caller, profile);
            self.referral_codes.write(code, caller);

            let count = self.referrer_count.read();
            self.referrer_count.write(count + 1);

            self.emit(ReferrerRegistered {
                referrer: caller,
                referral_code: code,
                timestamp: get_block_timestamp(),
            });

            code
        }

        fn register_referrer_with_code(ref self: ContractState, code: felt252) -> bool {
            self._require_not_paused();

            let caller = get_caller_address();

            // Check not already registered
            let existing = self.referrer_profiles.read(caller);
            assert!(existing.referral_code == 0, "Already registered as referrer");

            // Check code not taken
            let existing_owner = self.referral_codes.read(code);
            if !existing_owner.is_zero() {
                return false;  // Code already taken
            }

            // Validate code (must be non-zero and alphanumeric-ish)
            assert!(code != 0, "Invalid code");

            // Create profile
            let profile = ReferrerProfile {
                referral_code: code,
                tier: ReferrerTier::Bronze,
                total_referrals: 0,
                active_referrals: 0,
                total_volume_usd: 0,
                total_rewards_earned: 0,
                pending_rewards: 0,
                registered_at: get_block_timestamp(),
                is_active: true,
            };

            self.referrer_profiles.write(caller, profile);
            self.referral_codes.write(code, caller);

            let count = self.referrer_count.read();
            self.referrer_count.write(count + 1);

            self.emit(ReferrerRegistered {
                referrer: caller,
                referral_code: code,
                timestamp: get_block_timestamp(),
            });

            true
        }

        fn claim_rewards(ref self: ContractState) -> u256 {
            let caller = get_caller_address();
            let mut profile = self.referrer_profiles.read(caller);

            assert!(profile.pending_rewards > 0, "No rewards to claim");

            let amount = profile.pending_rewards;
            profile.pending_rewards = 0;
            self.referrer_profiles.write(caller, profile);

            // Transfer rewards
            let token = IERC20Dispatcher { contract_address: self.reward_token.read() };
            token.transfer(caller, amount);

            self.emit(RewardsClaimed {
                referrer: caller,
                amount,
                timestamp: get_block_timestamp(),
            });

            amount
        }

        fn get_referrer_profile(self: @ContractState, referrer: ContractAddress) -> ReferrerProfile {
            self.referrer_profiles.read(referrer)
        }

        fn get_referrer_by_code(self: @ContractState, code: felt252) -> ContractAddress {
            self.referral_codes.read(code)
        }

        fn register_with_referral(ref self: ContractState, referral_code: felt252) {
            self._require_not_paused();

            let caller = get_caller_address();
            let config = self.config.read();

            // Check not already referred
            let existing = self.referred_users.read(caller);
            assert!(existing.referrer.is_zero(), "Already has referrer");

            // Get referrer from code
            let referrer = self.referral_codes.read(referral_code);
            assert!(!referrer.is_zero(), "Invalid referral code");

            // Block self-referral
            if config.block_self_referral {
                assert!(referrer != caller, "Cannot refer yourself");
            }

            // Create referred user record
            let referred = ReferredUser {
                referrer,
                referred_at: get_block_timestamp(),
                total_volume_usd: 0,
                total_fees_generated: 0,
                last_trade_at: 0,
                is_active: false,
            };
            self.referred_users.write(caller, referred);

            // Update referrer stats
            let mut profile = self.referrer_profiles.read(referrer);
            profile.total_referrals += 1;
            self.referrer_profiles.write(referrer, profile);

            // Add to referrer's list
            let ref_count = self.referrer_referrals_count.read(referrer);
            self.referrer_referrals.write((referrer, ref_count), caller);
            self.referrer_referrals_count.write(referrer, ref_count + 1);

            let count = self.referred_count.read();
            self.referred_count.write(count + 1);

            self.emit(UserReferred {
                user: caller,
                referrer,
                referral_code,
                timestamp: get_block_timestamp(),
            });
        }

        fn get_referral_info(self: @ContractState, user: ContractAddress) -> ReferredUser {
            self.referred_users.read(user)
        }

        fn has_referrer(self: @ContractState, user: ContractAddress) -> bool {
            let referred = self.referred_users.read(user);
            !referred.referrer.is_zero()
        }

        fn record_trade(
            ref self: ContractState,
            trader: ContractAddress,
            volume_usd: u256,
            fee_amount: u256,
            fee_token: ContractAddress
        ) {
            // Only authorized callers
            self._only_authorized();
            self._require_not_paused();

            // Check if trader has a referrer
            let mut referred = self.referred_users.read(trader);
            if referred.referrer.is_zero() {
                return;  // No referrer, nothing to do
            }

            let now = get_block_timestamp();
            let config = self.config.read();

            // Update referred user stats
            referred.total_volume_usd += volume_usd;
            referred.total_fees_generated += fee_amount;
            referred.last_trade_at = now;

            // Check if now active
            if volume_usd >= config.min_active_volume_usd && !referred.is_active {
                referred.is_active = true;

                // Update referrer's active count
                let mut profile = self.referrer_profiles.read(referred.referrer);
                let old_tier = profile.tier;
                profile.active_referrals += 1;

                // Check for tier upgrade
                let new_tier = self._calculate_tier_internal(profile.active_referrals, @config);
                if new_tier != old_tier {
                    profile.tier = new_tier;
                    self.emit(TierUpgrade {
                        referrer: referred.referrer,
                        old_tier,
                        new_tier,
                        active_referrals: profile.active_referrals,
                    });
                }

                self.referrer_profiles.write(referred.referrer, profile);
            }

            self.referred_users.write(trader, referred);

            // Calculate and distribute referrer reward
            let mut profile = self.referrer_profiles.read(referred.referrer);
            let fee_share_bps = self._get_fee_share_bps(profile.tier, @config);
            let referrer_reward = (fee_amount * fee_share_bps.into()) / BPS_DENOMINATOR;

            if referrer_reward > 0 {
                profile.total_volume_usd += volume_usd;
                profile.pending_rewards += referrer_reward;
                profile.total_rewards_earned += referrer_reward;
                self.referrer_profiles.write(referred.referrer, profile);

                // Update global stats
                let total_vol = self.total_volume_usd.read() + volume_usd;
                self.total_volume_usd.write(total_vol);

                let total_rewards = self.total_rewards_distributed.read() + referrer_reward;
                self.total_rewards_distributed.write(total_rewards);

                self.emit(TradeRecorded {
                    trader,
                    referrer: referred.referrer,
                    volume_usd,
                    fee_amount,
                    referrer_reward,
                });
            }
        }

        fn get_config(self: @ContractState) -> ReferralConfig {
            self.config.read()
        }

        fn get_stats(self: @ContractState) -> (u256, u256, u32, u32) {
            (
                self.total_volume_usd.read(),
                self.total_rewards_distributed.read(),
                self.referrer_count.read(),
                self.referred_count.read()
            )
        }

        fn get_fee_share(self: @ContractState, tier: ReferrerTier) -> u32 {
            let config = self.config.read();
            self._get_fee_share_bps(tier, @config)
        }

        fn calculate_tier(self: @ContractState, active_referrals: u32) -> ReferrerTier {
            let config = self.config.read();
            self._calculate_tier_internal(active_referrals, @config)
        }

        fn set_config(ref self: ContractState, config: ReferralConfig) {
            self._only_owner();

            // Validate
            assert!(config.bronze_fee_share_bps <= 5000, "Bronze share too high");
            assert!(config.silver_fee_share_bps <= 5000, "Silver share too high");
            assert!(config.gold_fee_share_bps <= 5000, "Gold share too high");
            assert!(config.platinum_fee_share_bps <= 5000, "Platinum share too high");

            assert!(config.silver_threshold > 0, "Invalid silver threshold");
            assert!(config.gold_threshold > config.silver_threshold, "Gold must > silver");
            assert!(config.platinum_threshold > config.gold_threshold, "Platinum must > gold");

            self.config.write(config);

            self.emit(ConfigUpdated { updated_by: get_caller_address() });
        }

        fn add_authorized_caller(ref self: ContractState, caller: ContractAddress) {
            self._only_owner();
            self.authorized_callers.write(caller, true);
        }

        fn remove_authorized_caller(ref self: ContractState, caller: ContractAddress) {
            self._only_owner();
            self.authorized_callers.write(caller, false);
        }

        fn pause(ref self: ContractState) {
            self._only_owner();
            let mut config = self.config.read();
            config.paused = true;
            self.config.write(config);
        }

        fn unpause(ref self: ContractState) {
            self._only_owner();
            let mut config = self.config.read();
            config.paused = false;
            self.config.write(config);
        }

        fn emergency_withdraw(ref self: ContractState, token: ContractAddress, amount: u256) {
            self._only_owner();
            assert!(self.config.read().paused, "Must be paused");

            let token_dispatcher = IERC20Dispatcher { contract_address: token };
            token_dispatcher.transfer(self.owner.read(), amount);
        }
    }

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        fn _only_owner(self: @ContractState) {
            assert!(get_caller_address() == self.owner.read(), "Only owner");
        }

        fn _only_authorized(self: @ContractState) {
            let caller = get_caller_address();
            assert!(
                caller == self.owner.read() || self.authorized_callers.read(caller),
                "Not authorized"
            );
        }

        fn _require_not_paused(self: @ContractState) {
            assert!(!self.config.read().paused, "System paused");
        }

        fn _generate_code(ref self: ContractState, user: ContractAddress) -> felt252 {
            let nonce = self.code_nonce.read();
            self.code_nonce.write(nonce + 1);

            // Generate code from user address + nonce
            let user_felt: felt252 = user.into();
            let nonce_felt: felt252 = nonce.try_into().unwrap();

            // Simple deterministic code generation
            user_felt + nonce_felt
        }

        fn _calculate_tier_internal(
            self: @ContractState,
            active_referrals: u32,
            config: @ReferralConfig
        ) -> ReferrerTier {
            if active_referrals >= *config.platinum_threshold {
                ReferrerTier::Platinum
            } else if active_referrals >= *config.gold_threshold {
                ReferrerTier::Gold
            } else if active_referrals >= *config.silver_threshold {
                ReferrerTier::Silver
            } else {
                ReferrerTier::Bronze
            }
        }

        fn _get_fee_share_bps(self: @ContractState, tier: ReferrerTier, config: @ReferralConfig) -> u32 {
            match tier {
                ReferrerTier::Bronze => *config.bronze_fee_share_bps,
                ReferrerTier::Silver => *config.silver_fee_share_bps,
                ReferrerTier::Gold => *config.gold_fee_share_bps,
                ReferrerTier::Platinum => *config.platinum_fee_share_bps,
            }
        }
    }
}
